# 思路走向

给定一个问题，数据结构跟随着看问题的角度，而看问题的角度又能抽象出不同模型。遇到一个问题，分析步骤如下：

+ 问题转化：变化复杂问题变换成变化简单问题
+ 基本问题：数组、链表、栈、队列、树、图的基本问题以及交换、排序、查找
+ 非基本问题性质：线性关系还是非线性关系
+ 非线性关系：规模+1后是否是子问题，否则是回溯
+ 如无思路，按普通解决方法解决出后，思考有没有更好的时间复杂度的解决方案。时间复杂度也能提供一下思路



# 性能分析

时间复杂度，尤其是递归

空间复杂度，尤其是递归



# 数据结构

## 数组

主要是双指针的运用：

+ 删除：从左到右->27. 移除元素
+ 替换：从右到左->剑指Offer 05.替换空格
+ 反转：从中间到两边->151.翻转字符串里的单词、15.三数之和、18. 四数之和、快排
+ 窗口：209.长度最小的子数组、**239. 滑动窗口最大值**

额外：

+ KMP(字符串子串匹配)：28. 实现 strStr(也可以用动归解决，即两个字符串的最长公共长度首次为子串长度时)、459.重复的子字符串

## 链表

基本操作和双指针的运用：

+ 删除：第203题：移除链表元素

+ 反转：206题：反转链表
+ 环：142题.环形链表II

## 栈

核心在后进先出，经常与回溯结合，除此还经常解决如下问题：

+ 匹配：20. 有效的括号

## 队列

核心在后进后出

问题暂无

## 树

+ 遍历：层序、前序、中序、后序的递归和非递归：102.二叉树的层序遍历、144.二叉树的前序遍历、94.二叉树的中序遍历、145.二叉树的后序遍历

  > + 层序遍历：用数组存储，具有位置相关性。层序主要涉及到平均值、左右视图、深度，如：
  >
  >   > + 637.二叉树的层平均值
  >   > + 513.找树左下角的值、199.二叉树的右视图
  >   > + 111.二叉树的最小深度、104.二叉树的最大深度
  >
  > + 前序遍历：用于自上向下的问题处理节点问题
  >
  >   > + 257.二叉树的所有路径
  >   > + 404.左叶子之和
  >
  > + 中序遍历：以及节点左右是两棵子数，对应的搜索树其实就是一个有序数组
  >
  >   > + 530.二叉搜索树的最小绝对差
  >
  > + 后续遍历：用于自下向上的问题处理根点问题
  >
  >   > + 236.二叉树的最近公共祖先
  >   > + 235.二叉搜索树的最近公共祖先

+ 验证：满、完全、平衡(110.平衡二叉树)、搜索(98.验证二叉搜索树)、对称

+ 构造：根据中序和某序构造树：105. 从前序与中序遍历序列构造二叉树、106.从中序与后序遍历序列构造二叉树

+ 操作：搜索树插入(701.二叉搜索树中的插入操作)、搜索树删除(450.删除二叉搜索树中的节点)、普通树翻转(226.翻转二叉树)

## 图

图论：最短路、最小生成树、网络流建模

https://www.sohu.com/a/325054765_100281831



# 算法思想

以下思想都是解决非线性关系的问题，主要是**排列组合衍生问题(比如分割、子集等问题)**：

问题可以划分为子问题==》

+ (独立子问题且求集合)分治
+ (重叠子问题且求最值、数量)动归

否则，利用回溯(称为万能钥匙)解决。

## 分治

模版，经典题目快排：

```
暂无
```

**分治算法解决的问题都可以抽象为二叉树**，解决问题特点：

> 分治算法的解是回溯算法排列组合的某个

+ <u>随着问题规模n变大(比如推导+1的情况)，问题保持不变性(即能划分为子问题)</u>。这是不用回溯最重要的一点
+ 独立子问题：互相独立==>同层子树无关
+ 合并结果解：合并==>叶子节点的集合为解(一般求的问题为具体某个集合)

问题如下：

+ 排序：快排、归并



## 动规

模版，经典题目斐波那契：

```
确定dp数组(维度：与状态相关的变量)以及下标含义//这一步在推倒递推公式时逐步确定的，初始为一维(即问题规模的变化n,然后逐步增加维度)
确定递推公式// 不同选择关系的整理，一定要理清楚考虑全面后再行动--重要，重要，重要
dp数组如何初始化
确定遍历顺序
推导dp数组
```

**动态规划解决的问题都可以抽象为n维数组的策略关系。未优化数组的前提下，数组单元的数值代表状态，每一维代表一种与状态相关的变量**，解决问题特点：

+ <u>随着问题规模n变大(比如推导+1的情况)，问题保持不变性(即能划分为子问题)</u>。这是不用回溯最重要的一点

+ 重叠子问题：前向依赖

+ 最优结果解：最优(一般求的问题为最值、是否、组合数)

  > 比如组合数的递推关系f(n) = 2f(n-1)，普通组合也是有递推的。因此求组合数就是求新规则下的递推关系。

数组(空间)优化(滚动数组)：二维变一维，一维变单量。

问题如下：

+ 楼梯问题：70. 爬楼梯、746. 使用最小花费爬楼梯、343. 整数拆分

+ 背包问题：基本问题为最值，演变问题为是否以及组合数，有空再看背包九讲

  > ![](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6xPu8BiaJQNCasvLUeXpIGBffZQW7TxLmyfMAg0HaxVSex3FPkWh3ic88SRTXFlvz3XnVpdicWWlzYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
  >
  > + 零一背包：416. 分割等和子集、1049. 最后一块石头的重量 II、494. 目标和、*474.一和零*
  > + 完全背包：518. 零钱兑换 II、377. 组合总和 Ⅳ、70. 爬楼梯、322. 零钱兑换、279.完全平方数、139.单词拆分

+ 子串问题：674. 最长连续递增序列、300.最长递增子序列、718. 最长公共连续子序列、1143.最长公共子序列、53. 最大子序和、*72. 编辑距离*、392.判断子序列、115.不同的子序列、583. 两个字符串的删除操作

+ 买卖股票：121. 买卖股票的最佳时机、122.买卖股票的最佳时机II、123.买卖股票的最佳时机III、188.买卖股票的最佳时机IV、309.买卖股票的最佳时机含冷冻期、714.买卖股票的最佳时机含手续费

+ 打家劫舍：198.打家劫舍、213.打家劫舍II、337.打家劫舍 III

+ 路径问题：62.不同路径、63. 不同路径 II



## 回溯

模版，经典题目汉诺塔：

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {// 循环-->横向遍历
        处理节点;// 入栈(存储访问顺序)
        backtracking(路径，选择列表); // 递归-->纵向遍历
        回溯节点;// 出栈(存储访问顺序)
    }
}
```

**回溯算法(被称为万能钥匙)解决的问题都可以抽象为树形结构**，多用于求结果的集合。

问题如下：

+ 排列：46.全排列、47.全排列 II

+ 组合：

  > + 普通：77. 组合、39. 组合总和、40.组合总和II、216.组合总和III、17.电话号码的字母组合
  > + 分割：131.分割回文串、93.复原IP地址
  > + 子集：78.子集、90.子集II、491.递增子序列
  > + 棋盘：37. 解数独、51. N皇后



# 草稿

排序算法：快速排序、归并排序、计数排序

搜索算法：回溯、递归、剪枝技巧

动态规划：背包问题、最长子序列、计数问题

基础技巧：分治、倍增、二分、贪心