# 递归思想

定义：从已知问题的结果出发，用等价关系表达式逐步推算出问题的开始条件，称为递归。即：**一个问题可以划分为同样的<u>子问题</u>，且有停止条件**。

> 区别：递推是从已知到未知，与我们的思维相似；递归是从未知到已知，与我们的思维相反。
>

过程：**递归的过程就是出入栈的过程**。递归函数的实质就是系统在帮我们压栈，这是一种程序的自身调用。在调用过程中，每次将程序执行现场压栈，直到递归出口返回信息，再弹栈继续执行，直到栈空。

时间复杂度：符合复杂度分析公式**T(N) = a*T(N/b) + O(N^d)**的都可用master公式判断时间复杂度。其中b为划分为几个子过程，a为发生的次数：

1) log(b,a) > d -> 复杂度为O(N^log(b,a)) 

2) log(b,a) = d -> 复杂度为O(N^d * logN) 

3) log(b,a) < d -> 复杂度为O(N^d)

## 一、思路建立

一个递归思路的建立分为三部分：函数功能、函数结束条件、函数等价关系表达式。下面按照思路进行介绍：

+ **第一要素：明确递归函数的功能**

  对于递归很重要的一个事就是：这个函数要完成什么样的一件子事。也就是说先不管函数里面的代码什么，而是要先明白这个函数是要用来干什么。例如定义了一个函数，这个函数的功能是算 n 的阶乘：

  ```java
  // 算n的阶乘(假设n不为0)
  int f(int n){
      // todo
  }
  ```

+ **第二要素：寻找递归函数的结束条件(一般指归的起点)**

  所谓递归，就是在函数内部代码中调用这个函数本身。所以必须要找出**递归的结束条件**，不然的话会一直调用自己。也就是说需要找出**当参数为什么时递归才结束，之后直接把结果返回**，请注意这个时候必须能根据这个参数的值，能够直接知道函数的结果是什么。

  例如上面那个例子，当n=1时能够直接知道f(1) = 1。完善函数内部的代码，把第二要素加进代码里面，如下

  ```java
  // 算n的阶乘(假设n不为0)
  int f(int n){
      if(n == 1){
          return 1;
      }
      // todo
  }
  ```

+ **第三要素：找出递归函数的等价关系(归的逻辑关系)**

  第三要素就是要**不断缩小参数的范围**，缩小之后可以通过一些辅助的变量或者操作，使原函数的结果不变。

  > 这个等价关系式的寻找，可以说是最难的一步了，需要多加练习，慢慢熟悉起来。

  例如f(n)这个范围比较大，可以让 f(n) = n * f(n-1)。这样范围就由n变成了n-1了。范围变小且为了原函数f(n) 不变，需要让 f(n-1) 乘以 n。说白了就是要找到原函数的一个等价关系式，f(n)的等价关系式为f(n) = n * f(n-1)。找出了这个等价继续完善代码，把这个等价式写进函数里，如下：

  ```java
  // 算n的阶乘(假设n不为0)
  int f(int n){
      if(n <= 2){
          return n;
      }
      // 把f(n)的等价操作写进去
      return f(n-1) * n;
  }
  ```

这就是递归结构最重要的三要素。每次做递归的时候，就强迫自己试着去寻找这三个要素。

如使用递归时不进行优化，是有非常非常多的子问题被重复计算的。如对于案例2那道题f(n) = f(n-1) + f(n-2)，递归调用的状态图如下：

![https://blog.csdn.net/dreamispossible/article/details/90552557](https://img-blog.csdnimg.cn/20190525223009949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RyZWFtaXNwb3NzaWJsZQ==,size_16,color_FFFFFF,t_70)

看到没有，递归计算的时候重复计算了两次 f(5)、五次 f(4)...这是非常恐怖的。n越大重复计算的就越多，所以必须进行优化。

如何优化？一般可以用数组或HashMap把计算的结果保证起来。例如把f(4)的计算结果保证起来，当再次要计算f(4)的时候，先判断之前是否计算过，如果计算过，直接把f(4)的结果取出来就可以；没有计算过的话再递归计算。

## 二、循环形态



在递归调用的过程中，系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出。 解决这一问题有两种方法：尾递归或改为循环。

### 尾递归

尾递归优化指：在尾部进行函数调用时使用下一个栈结构覆盖当前栈结构，同时保持原来的返回地址。 它本质是对栈进行处理，删掉活动记录，在函数返回的时候，调用自身本身，并且return语句不能包含表达式。这样编译器或解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 注意，要使调用成为真正的尾部调用，在尾部调用函数返回前，对其结果不能执行任何其他操作。如：

```
def fact(n):
    return fact_iter(n, 1)
 
def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```

return fact_iter(num - 1, num * product)仅返回递归函数本身，num-1和num*product在函数调用前就会被计算，不影响函数调用。

### 循环

当n比较大(例如当n=10000时)，则必须要往下递归10000层直到n <=1才将结果慢慢返回，如果n太大，可能会导致栈溢出。对于这种情况，可考虑采用循环形式(**只要允许使用栈，所有递归都能转化为循环**)：系统是根据栈来实现递归的，即也可考虑模拟栈的行为来将递归转化为循环，该情况这里就略过；但并非所有递归都必须用栈，不用堆栈也可以转化成迭代的，如尾递归可以直接转化成循环。

更通俗的思路需要进一步学习。

## 三、案例分析

### 案例1：斐波那契数列

> 斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34…，求第 n 项的值是多少

### 案例2：小青蛙跳台阶

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法

### 案例3：反转单链表

> 反转单链表。例如链表为1->2->3->4。反转后为4->3->2->1。其中链表的节点定义如下：
>
> ```java
> class Node{
>     int date;
>     Node next;
> }
> ```

 **1、定义递归函数功能**

假设函数reverse(head)的功能是反转链表，其中head表示链表的头节点。代码如下：

```java
Node reverse(Node head){
    // todo
}
```

**2、寻找递归函数结束条件**

当链表只有一个节点时返回。代码如下：

```java
Node reverse(Node head){
    if(head == null || head.next == null){
        return head;
    }
    // todo
}
```

 **3、寻找递归函数等价关系**

这个的等价关系不容易寻找。先缩小范围，先对 2->3->4递归下试试，即代码如下：

```java
Node reverse(Node head){ 
    if(head == null || head.next == null){
        return head; 
    } // 先把递归的结果保存起来而先不返回，因为还不清楚这样递归是对还是错
    Node newList = reverse(head.next);
    // todo
}
```

在第一步的时候就已经定义reverse函数的功能可以把一个单链表反转，所以对2->3->4反转之后的结果应该是这样：

```mermaid
graph LR;

newList(new)-->node4;
node4-->node3;
node3-->node2;
node1-->node2;
head(head)-->node1;
```

把2->3->4递归成4->3->2。不过1这个节点并没有去碰它，所以1的next节点仍然是连接着node2。接下来该怎么办？接下来就简单了，只需要**把节点2的next指向1，然后把1的next指向null，不就行了**。即通过改变newList链表之后的结果如下：

```mermaid
graph LR;

newList(new)-->node4;
node4-->node3;
node3-->node2;
node2-->node1;
node1-->null(null);
```

也就是说，reverse(head) 等价于 reverse(head.next) + 改变一下1，2两个节点的指向。这样等价关系找出来了，代码如下：

```java
//用递归的方法反转链表 
public static Node reverse(Node node){ 
    // 递归结束条件
    if (node == null || node.next == null){
        return node; 
    } 
    // 递归反转子链表 
    Node temp = reverse(node.next);
    node.next.next = node; 
    node.next = null;
    // 把调整之后的链表返回
    return temp;
}
```





