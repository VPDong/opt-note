# 回溯思想

定义：回溯算法，又称为“试探法”。解决问题时，每进行一步，都是抱着试试看的态度，如发现当前选择并不是最好的，或这么走下去肯定达不到目标，立刻做回退操作重新选择。这种走不通就回退再走的方法就是回溯。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。回溯问题的关键在于如何定义问题的解空间，转化成树(即解空间树)。解空间树分为两种：子集树和排列树，两种在算法结构和思路上大体相同。

+ 子集树：所给问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间成为子集树。回溯搜索子集树的算法范式如下：

  > 如旅行售货员问题，一个售货员把几个城市旅行一遍，要求走的路程最小。它的解就是几个城市的排列，解空间就是排列树。

  ```
  void backtrack (int t) {  
    if (t>n) output(x);  
      else  
        for (int i=0;i<=1;i++) {  
          x[t]=i;  
          if (constraint(t)&&bound(t)) backtrack(t+1);  
        }  
  }
  ```
  
+ 排列树：所给的问题是确定n个元素满足某种性质的排列时，相应的解空间就是排列树。回溯搜索排列树的算法范式如下：

  > 如0-1背包问题，从所给重量、价值不同的物品中挑选几个物品放入背包，使得在满足背包不超重的情况下，背包内物品价值最大。它的解空间就是一个典型的子集树。

  ```
  void backtrack (int t) {  
    if (t>n) output(x);  
      else  
        for (int i=t;i<=n;i++) {  
          swap(x[t], x[i]);  
          if (constraint(t)&&bound(t)) backtrack(t+1);  
          swap(x[t], x[i]);  
        }  
  }
  ```

> 回溯法从问题本身出发，寻找可能实现的所有情况。和穷举相近，不同在于穷举是将所有的情况都列举出来以后再一一筛选，而回溯法在列举过程如果发现当前情况根本不可能存在，就停止后续的所有工作，返回上一步进行新的尝试。
>
> 递归是从问题的结果出发，例如求n!，要想知道n!的结果，就需要知道n\*(n-1)!的结果，而要想知道(n-1)!结果，就需要提前知道 (n-1)\*(n-2)!。这样不断地向自己提问，不断地调用自己的思想就是递归。
>
> 回溯和递归唯一的联系就是，回溯法可用递归实现。

过程：使用回溯法解决问题的过程，实际上是建立一棵“状态树”的过程，其中递归的过程就是深度遍历。如在解决列举集合{1,2,3}所有子集的问题中，对于每个元素，都有两种状态，取还是舍，所以构建的状态树为：

![http://c.biancheng.net/view/3400.html](http://c.biancheng.net/uploads/allimg/190427/095Q11161-0.png)

回溯算法的求解过程实质上是先序遍历“状态树”的过程。树中每一个叶子结点，都有可能是问题的答案。图中的状态树是满[N叉树](http://c.biancheng.net/view/3384.html)，得到的叶子结点全部都是问题的解。**回溯实际上就是一个决策树的遍历过程，关键就是在前序遍历和后序遍历的位置做一些操作**

但在某些情况下，回溯算法解决问题的过程中创建的状态树并不都是满N叉树。因在试探过程中，有时会发现此种情况下，再往下进行没有意义，所以会放弃这条死路，回溯到上一步。在树中的体现，就是在树的最后一层不是满的(即不是满二叉树)，需要自己判断哪些叶子结点代表的是正确的结果。

## 一、思路建立

回溯法一般都用在要给出多个可以实现最终条件的解的最终形式。回溯法要求对解要添加一些约束条件。总的来说，如果要解决一个回溯法的问题，通常要确定三个元素：

1、条件。对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回。

2、选择。对于每个特定的解则是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择。要知道怎么选择，同时在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过递推或递归实现(用前序实施选择，后序撤销选择)。

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择(可选)
```

**在用递归实现时，递归函数的参数的选择，要注意：**

1、可以有一个全局变量，用来存储完整的每个解，一般是个集合容器(也不一定要有这样一个变量，因为每次符合结束条件，不完整解就是完整解了，直接打印即可)。

2、必须要有一个临时变量(可就直接传递一个字面量或者常量进去)传递不完整的解，因为每一步选择后，暂时还没构成完整的解，这个时候这个选择的不完整解，也要想办法传递给递归函数。也就是把每次递归的不同情况传递给递归调用的函数。

https://zhuanlan.zhihu.com/p/93530380

## 二、案例分析

### 迷宫问题

给定一个迷宫，找到从入口到出口的所有可行路径，并给出其中最短的路径

### 背包问题

给定一背包(容量为C)和n种物品，物品i的重量是wi，其价值为pi。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大

### N皇后问题

在n×n格的棋盘上放置彼此不受攻击的n个皇后。按照规则，皇后可攻击与之处在同行或同列或同一斜线上的棋子

### 生成括号的对数

给出n代表生成括号的对数，请写出一个函数，使其能够生成所有可能的并且**有效的**括号组合(力扣中国第22题)。

例如，给出 *n* = 3，生成结果为：["((()))", "(()())", "(())()", "()(())", "()()()"]

### 列举集合的子集

在解决列举集合 {1,2,3} 中所有子集的问题中，就可以使用回溯算法。从集合的开头元素开始，对每个元素都有两种选择：取还是舍。当确定了一个元素的取舍之后，再进行下一个元素，直到集合最后一个元素。其中的每个操作都可以看作是一次尝试，每次尝试都可以得出一个结果。将得到的结果综合起来，就是集合的所有子集。

```c
#include <stdio.h>
//设置一个数组，数组的下标表示集合中的元素，所以数组只用下标为1，2，3的空间
int set[5];
//i代表数组下标，n表示集合中最大的元素值
void PowerSet(int i,int n){
    //当i>n时，说明集合中所有的元素都做了选择，开始判断
    if (i>n) {
        for (int j=1; j<=n; j++) {
            //如果树组中存放的是 1，说明在当初尝试时，选择取该元素，即对应的数组下标，所以，可以输出
            if (set[j]==1) {
                printf("%d ",j);
            }
        }
        printf("\n");
    }else{
        //如果选择要该元素，对应的数组单元中赋值为1；反之，赋值为0。然后继续向下探索
        set[i]=1;PowerSet(i+1, n);
        set[i]=0;PowerSet(i+1, n);
    }
}
int main() {
    int n=3;
    for (int i=0; i<5; i++) {
        set[i]=0;
    }
    PowerSet(1, n);
    return 0;
}
```

详情参考[这里](https://zhuanlan.zhihu.com/p/120393175)和[这里](https://blog.csdn.net/weiyuefei/article/details/79316653)

